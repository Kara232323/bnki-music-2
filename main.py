#!/usr/bin/env python3
# Telegram Music Bot
# Generated by Telegram Music Bot Maker

import os
import asyncio
import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import yt_dlp
import requests

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration - Get from environment variables
BOT_TOKEN = os.getenv("8138462822:AAFh8pV4tW2euSuNAnp597-rje3UqFP_Nzg")
API_ID = os.getenv("29887059")
API_HASH = os.getenv("8173fb6e839cc131ab2341d59763be60")

# Admin configuration
ADMIN_IDS = [int(os.getenv("ADMIN_ID", "0"))] if os.getenv("@Karan_vi") else []

# Song queue
SONG_QUEUE = {}

# Start command
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a message when the command /start is issued."""
    welcome_text = """
üéµ **Welcome to Music Bot!**

I can help you download music from YouTube!

**Commands:**
/start - Start the bot
/help - Show this help message
/play <song name> - Search and download music
/search <query> - Search for songs
/queue - Show current queue

Just send me a song name and I'll find it for you!

Made with ‚ù§Ô∏è by Music Bot Maker
    """
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

# Help command
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send help message."""
    help_text = """
üéµ **Music Bot Help**

**Available Commands:**
‚Ä¢ /start - Start the bot
‚Ä¢ /help - Show this help
‚Ä¢ /play <song> - Download a song
‚Ä¢ /search <query> - Search for songs
‚Ä¢ /queue - Show download queue

**How to use:**
1. Send `/play Despacito` to download a song
2. Send `/search Justin Bieber` to search
3. Just type a song name for quick search

**Examples:**
‚Ä¢ `/play Shape of You Ed Sheeran`
‚Ä¢ `/search Bollywood songs`
‚Ä¢ `Blinding Lights`

Enjoy the music! üé∂
    """
    await update.message.reply_text(help_text, parse_mode='Markdown')

# Play command
async def play_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle play command."""
    if not context.args:
        await update.message.reply_text("‚ùå Please provide a song name!\n\nExample: `/play Despacito`", parse_mode='Markdown')
        return
    
    song_name = ' '.join(context.args)
    chat_id = update.effective_chat.id
    
    # Add to queue
    if chat_id not in SONG_QUEUE:
        SONG_QUEUE[chat_id] = []
    
    SONG_QUEUE[chat_id].append(song_name)
    
    await update.message.reply_text(f"üîç Searching for: **{song_name}**\n‚è≥ Please wait...", parse_mode='Markdown')
    
    try:
        # Use yt-dlp to search and get info
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extractaudio': True,
            'audioformat': 'mp3',
            'outtmpl': '%(title)s.%(ext)s',
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Search for the song
            search_query = f"ytsearch1:{song_name}"
            info = ydl.extract_info(search_query, download=False)
            
            if info and 'entries' in info and info['entries']:
                video_info = info['entries'][0]
                title = video_info.get('title', 'Unknown')
                uploader = video_info.get('uploader', 'Unknown')
                duration = video_info.get('duration', 0)
                url = video_info.get('webpage_url', '')
                
                # Format duration
                duration_str = f"{duration//60}:{duration%60:02d}" if duration else "Unknown"
                
                result_text = f"""
üéµ **Found:**
**Title:** {title}
**Artist/Channel:** {uploader}
**Duration:** {duration_str}
**URL:** {url}

‚¨áÔ∏è Download starting...
                """
                
                await update.message.reply_text(result_text, parse_mode='Markdown')
                
                # Note: Actual download would happen here
                # For now, just send success message
                await update.message.reply_text(f"‚úÖ **{title}** added to your music library!\n\nüé∂ Enjoy your music!", parse_mode='Markdown')
                
            else:
                await update.message.reply_text(f"‚ùå Sorry, couldn't find: **{song_name}**\n\nTry a different search term!", parse_mode='Markdown')
    
    except Exception as e:
        logger.error(f"Error in play_command: {e}")
        await update.message.reply_text(f"‚ùå Error occurred while searching for: **{song_name}**\n\nPlease try again!", parse_mode='Markdown')

# Search command
async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle search command."""
    if not context.args:
        await update.message.reply_text("‚ùå Please provide search query!\n\nExample: `/search Ed Sheeran`", parse_mode='Markdown')
        return
    
    query = ' '.join(context.args)
    await update.message.reply_text(f"üîç Searching for: **{query}**\n‚è≥ Please wait...", parse_mode='Markdown')
    
    try:
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            search_query = f"ytsearch5:{query}"
            info = ydl.extract_info(search_query, download=False)
            
            if info and 'entries' in info and info['entries']:
                results_text = f"üîç **Search Results for:** {query}\n\n"
                
                for i, video in enumerate(info['entries'][:5], 1):
                    title = video.get('title', 'Unknown')
                    uploader = video.get('uploader', 'Unknown')
                    duration = video.get('duration', 0)
                    duration_str = f"{duration//60}:{duration%60:02d}" if duration else "?"
                    
                    results_text += f"**{i}.** {title}\n"
                    results_text += f"   üë§ {uploader} | ‚è±Ô∏è {duration_str}\n\n"
                
                results_text += f"üí° Use `/play <song name>` to download any of these!"
                
                await update.message.reply_text(results_text, parse_mode='Markdown')
            else:
                await update.message.reply_text(f"‚ùå No results found for: **{query}**", parse_mode='Markdown')
    
    except Exception as e:
        logger.error(f"Error in search_command: {e}")
        await update.message.reply_text(f"‚ùå Error occurred while searching for: **{query}**", parse_mode='Markdown')

# Queue command
async def queue_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show current queue."""
    chat_id = update.effective_chat.id
    
    if chat_id not in SONG_QUEUE or not SONG_QUEUE[chat_id]:
        await update.message.reply_text("üì≠ Queue is empty!\n\nUse `/play <song>` to add songs.", parse_mode='Markdown')
        return
    
    queue_text = "üìã **Current Queue:**\n\n"
    for i, song in enumerate(SONG_QUEUE[chat_id], 1):
        queue_text += f"**{i}.** {song}\n"
    
    await update.message.reply_text(queue_text, parse_mode='Markdown')

# Handle text messages (auto-search)
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle regular text messages as song search."""
    text = update.message.text.strip()
    
    if len(text) < 3:
        await update.message.reply_text("‚ùå Please send a longer song name (at least 3 characters)")
        return
    
    # Treat as search query
    await update.message.reply_text(f"üîç Auto-searching for: **{text}**\n\nUse `/play {text}` to download!", parse_mode='Markdown')

# Error handler
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    """Log errors caused by Updates."""
    logger.error(f"Exception while handling an update: {context.error}")

def main():
    """Start the bot."""
    # Check for required environment variables
    if not BOT_TOKEN:
        logger.error("‚ùå ERROR: BOT_TOKEN not found!")
        logger.error("Please set BOT_TOKEN in Railway environment variables")
        return
    
    logger.info("üöÄ Starting Telegram Music Bot...")
    logger.info(f"üì± Bot Token: {BOT_TOKEN[:10]}...")
    
    # Create the Application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("play", play_command))
    application.add_handler(CommandHandler("search", search_command))
    application.add_handler(CommandHandler("queue", queue_command))
    
    # Add text message handler
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Add error handler
    application.add_error_handler(error_handler)
    
    # Start the bot
    logger.info("‚úÖ Music Bot is running!")
    logger.info("Press Ctrl+C to stop the bot")
    
    # Run with polling (better for Railway)
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()

