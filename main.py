Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:37:50) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license()" for more information.
>>> #!/usr/bin/env python3
# Telegram Music Bot
# Generated by Telegram Music Bot Maker

import os
import asyncio
import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import yt_dlp
import requests
from config import BOT_TOKEN, API_ID, API_HASH

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
ADMIN_IDS = ['@Karan_vi']  # Add your Telegram user ID here
SONG_QUEUE = {}
CURRENT_SONG = {}

# YouTube-DL configuration
ydl_opts = {
    'format': 'bestaudio/best',
    'outtmpl': '%(title)s.%(ext)s',
    'noplaylist': True,
}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send a message when the command /start is issued."""
    welcome_msg = f"""
ğŸµ Welcome to {config['username']}!

I'm your personal music bot. Here's what I can do:

ğŸ§ Download music from YouTube
ğŸ” Search for songs
ğŸ“‹ Manage song queue
ğŸ”Š Volume control

**Commands:**
/play <song name> - Download a song
/search <query> - Search for music
/queue - Show current queue
/help - Show all commands

Just send me a song name and I'll find it for you! ğŸš€
    """
    
    await update.message.reply_text(welcome_msg)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show help message with all commands."""
    help_text = """
ğŸµ **Bot Commands:**

ğŸ§ **Music Commands:**
/play <song> - Download and send music
/search <query> - Search for songs
/download <song> - Download specific song

ğŸ“‹ **Queue Management:**
/queue - Show current song queue
/skip - Skip to next song
/clear - Clear the queue

ğŸ”Š **Audio Control:**
/volume <1-100> - Adjust volume
/pause - Pause current playback
/resume - Resume playback

âš™ï¸ **Other Commands:**
/start - Show welcome message
/help - Show this help
/status - Check bot status

Just type the song name and I'll find it! ğŸ¶
    """
    
    await update.message.reply_text(help_text)

async def play_song(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Download and send music from YouTube."""
    if not context.args:
        await update.message.reply_text("Please provide a song name! Example: /play Imagine Dragons Believer")
        return
    
    song_query = ' '.join(context.args)
    chat_id = update.effective_chat.id
    
    # Send loading message
    loading_msg = await update.message.reply_text(f"ğŸ” Searching for '{song_query}'...")
    
    try:
        # Search for the song
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            search_query = f"ytsearch:{song_query}"
            info = ydl.extract_info(search_query, download=False)
            
            if 'entries' in info and len(info['entries']) > 0:
                video = info['entries'][0]
                title = video['title']
                duration = video.get('duration', 0)
                url = video['webpage_url']
                
                # Update loading message
                await loading_msg.edit_text(f"â¬¬ Downloading '{title}'...")
                
                # Download the audio
                download_opts = ydl_opts.copy()
                download_opts['outtmpl'] = f"{chat_id}_%(title)s.%(ext)s"
                
                with yt_dlp.YoutubeDL(download_opts) as dl:
                    dl.download([url])
                
                # Find the downloaded file
                import glob
                files = glob.glob(f"{chat_id}_*")
                
                if files:
                    audio_file = files[0]
                    
                    # Send the audio file
                    with open(audio_file, 'rb') as audio:
                        await update.message.reply_audio(
                            audio=audio,
                            title=title,
                            duration=duration,
                            caption=f"ğŸµ {title}

ğŸ”— [Original Video]({url})"
                        )
                    
                    # Clean up
                    os.remove(audio_file)
                    await loading_msg.delete()
                else:
                    await loading_msg.edit_text("âŒ Failed to download the song.")
            else:
                await loading_msg.edit_text(f"âŒ No results found for '{song_query}'")
                
    except Exception as e:
        logger.error(f"Error in play_song: {e}")
        await loading_msg.edit_text("âŒ An error occurred while processing your request.")

async def search_music(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Search for music on YouTube."""
    if not context.args:
        await update.message.reply_text("Please provide a search query! Example: /search Taylor Swift")
        return
    
    query = ' '.join(context.args)
    
    try:
        with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
            search_query = f"ytsearch5:{query}"
            info = ydl.extract_info(search_query, download=False)
            
            if 'entries' in info and len(info['entries']) > 0:
                results = "ğŸ” **Search Results:**

"
                
                for i, video in enumerate(info['entries'][:5], 1):
                    title = video['title']
                    duration = video.get('duration', 0)
                    channel = video.get('uploader', 'Unknown')
                    
                    duration_str = f"{duration//60}:{duration%60:02d}" if duration else "Unknown"
                    
                    results += f"{i}. **{title}**
"
                    results += f"   ğŸ“º {channel} | â±ï¸ {duration_str}

"
                
                results += "To download any song, use: /play <song name>"
                
                await update.message.reply_text(results)
            else:
                await update.message.reply_text(f"âŒ No results found for '{query}'")
                
    except Exception as e:
        logger.error(f"Error in search_music: {e}")
        await update.message.reply_text("âŒ An error occurred while searching.")

async def show_queue(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show current song queue."""
    chat_id = update.effective_chat.id
    
    if chat_id not in SONG_QUEUE or not SONG_QUEUE[chat_id]:
        await update.message.reply_text("ğŸ“‹ Queue is empty!")
        return
    
    queue_text = "ğŸ“‹ **Current Queue:**

"
    for i, song in enumerate(SONG_QUEUE[chat_id], 1):
        queue_text += f"{i}. {song}
"
    
    await update.message.reply_text(queue_text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle regular messages as music requests."""
    message = update.message.text
    
    # Skip if it's a command
    if message.startswith('/'):
        return
    
    # Treat regular messages as song requests
    context.args = message.split()
    await play_song(update, context)

async def bot_status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show bot status."""
    status_msg = """
ğŸ¤– **Bot Status:**

âœ… Bot is online and running
ğŸµ Music download: Active
ğŸ” Search function: Active
ğŸ“‹ Queue system: Active

**Stats:**
ğŸ“Š Uptime: Online
ğŸ’¾ Memory usage: Normal
ğŸŒ Connection: Stable
    """
    
    await update.message.reply_text(status_msg)

def main() -> None:
    """Start the bot."""
    # Create the Application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Register handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("play", play_song))
    application.add_handler(CommandHandler("search", search_music))
    application.add_handler(CommandHandler("queue", show_queue))
    application.add_handler(CommandHandler("status", bot_status))
    
    # Handle regular messages as music requests
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Start the bot
    print(f"ğŸµ Music Bot '{config['username']}' is starting...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
